import itertools
import json
import os
import re
import shutil
import time
from dataclasses import dataclass
from io import BytesIO

import requests
from PIL import Image
from pydantic import BaseModel
from requests.models import Response


class Panorama(BaseModel):
    pano_id: str
    lat: float
    lon: float
    heading: float
    tilt: float
    roll: float
    date: str | None


class Location(BaseModel):
    lat: float
    lng: float


class MetaData(BaseModel):
    date: str
    location: Location
    pano_id: str


def make_panoramas_url(lat: float, lon: float) -> str:
    """
    Builds the URL of the script on Google's servers that returns the closest
    panoramas (ids) to a give GPS coordinate.
    """
    url = (
        "https://maps.googleapis.com/maps/api/js/"
        "GeoPhotoService.SingleImageSearch"
        "?pb=!1m5!1sapiv3!5sUS!11m2!1m1!1b0!2m4!1m2!3d{0:}!4d{1:}!2d50!3m10"
        "!2m2!1sen!2sGB!9m1!1e2!11m4!1m3!1e2!2b1!3e2!4m10!1e1!1e2!1e3!1e4"
        "!1e8!1e6!5m1!1e2!6m1!1e2"
        "&callback=callbackfunc"
    )
    return url.format(lat, lon)


def panoramas_request(lat: float, lon: float) -> Response:
    """
    Gets the response of the script on Google's servers that returns the
    closest panoramas (ids) to a give GPS coordinate.
    """
    url = make_panoramas_url(lat, lon)
    return requests.get(url)


def extract_panoramas(text: str) -> list[Panorama]:
    """
    Given a valid response from the panoids endpoint, return a list of all the
    panoids.
    """

    # The response is actually javascript code. It's a function with a single
    # input which is a huge deeply nested array of items.
    blob = re.findall(r"callbackfunc\( (.*) \)$", text)[0]
    data = json.loads(blob)

    raw_panos = data[1][5][0][3][0]
    raw_dates = data[1][5][0][8]

    # For some reason, dates do not include a date for each panorama.
    # the n dates match the last n panos. Here we flip the arrays
    # so that the 0th pano aligns with the 0th date.
    raw_panos = raw_panos[::-1]
    raw_dates = raw_dates[::-1]

    dates = [f"{d[1][0]}-{d[1][1]:02d}" for d in raw_dates]

    return [
        Panorama(
            pano_id=pano[0][1],
            lat=pano[2][0][2],
            lon=pano[2][0][3],
            heading=pano[2][2][0],
            tilt=pano[2][2][1],
            roll=pano[2][2][2],
            date=dates[i] if i < len(dates) else None,
        )
        for i, pano in enumerate(raw_panos)
    ]


def get_panoramas(lat: float, lon: float) -> list[Panorama]:
    """
    Gets the closest panoramas (ids) to the GPS coordinates.
    """

    resp = panoramas_request(lat, lon)
    pans = extract_panoramas(resp.text)
    return pans


@dataclass
class Tile:
    x: int
    y: int
    filename: str
    fileurl: str


def tiles_info(panoid: str) -> list[Tile]:
    """
    Generate a list of a panorama's tiles and their position.

    The format is (x, y, filename, fileurl)
    """

    image_url = (
        "https://cbk0.google.com/cbk?output=tile&panoid={0:}&zoom=5&x={1:}&y={2:}"
    )

    # The tiles positions
    coord = list(itertools.product(range(26), range(13)))

    tiles = [
        Tile(
            x=x,
            y=y,
            filename="%s_%dx%d.jpg" % (panoid, x, y),
            fileurl=image_url.format(panoid, x, y),
        )
        for x, y in coord
    ]

    return tiles


def download_tiles(tiles: list[Tile], directory: str, disp: bool = False) -> None:
    """
    Downloads all the tiles in a Google Stree View panorama into a directory.

    Params:
        tiles - the list of tiles. This is generated by tiles_info(panoid).
        directory - the directory to dump the tiles to.
    """

    for i, tile in enumerate(tiles):
        if disp and i % 20 == 0:
            print("Image %d (%d)" % (i, len(tiles)))

        # Try to download the image file
        while True:
            try:
                response = requests.get(tile.fileurl, stream=True)
                break
            except requests.ConnectionError:
                print("Connection error. Trying again in 2 seconds.")
                time.sleep(2)

        with open(directory + "/" + tile.filename, "wb") as out_file:
            shutil.copyfileobj(response.raw, out_file)
        del response


def stich_tiles(
    panoid: str, tiles: list[Tile], directory: str, final_directory: str
) -> None:
    """
    Stiches all the tiles of a panorama together. The tiles are located in
    `directory'.
    """

    tile_width = 512
    tile_height = 512

    panorama = Image.new("RGB", (26 * tile_width, 13 * tile_height))

    for tile in tiles:
        fname = directory + "/" + tile.filename
        img = Image.open(fname)

        panorama.paste(im=img, box=(tile.x * tile_width, tile.y * tile_height))

        del img

    panorama.save(final_directory + ("/%s.jpg" % panoid))
    del panorama


def delete_tiles(tiles: list[Tile], directory: str) -> None:
    for tile in tiles:
        os.remove(directory + "/" + tile.filename)


def get_pano_metadata(panoid: str, api_key: str) -> MetaData:
    """
    Returns a panorama's metadata.

    Quota: This function doesn't use up any quota or charge on your API_KEY.

    Endpoint documented at:
    https://developers.google.com/maps/documentation/streetview/metadata
    """
    url = (
        "https://maps.googleapis.com/maps/api/streetview/metadata"
        f"?pano={panoid}&key={api_key}"
    )
    resp = requests.get(url)
    return MetaData(**resp.json())


def api_download(
    panoid: str,
    heading: int,
    flat_dir: str,
    key: str,
    width: int = 640,
    height: int = 640,
    fov: int = 120,
    pitch: int = 0,
    extension: str = "jpg",
    year: int = 2017,
    fname: str | None = None,
) -> str | None:
    """
    Download an image using the official API. These are not panoramas.

    Params:
        :panoid: the panorama id
        :heading: the heading of the photo. Each photo is taken with a 360
            camera. You need to specify a direction in degrees as the photo
            will only cover a partial region of the panorama. The recommended
            headings to use are 0, 90, 180, or 270.
        :flat_dir: the directory to save the image to (eg, C:\Users\SUNNY\Documents).
        :key: your API key.
        :width: downloaded image width (max 640 for non-premium downloads).
        :height: downloaded image height (max 640 for non-premium downloads).
        :fov: image field-of-view.
        :image_format: desired image format.
        :fname: file name

    You can find instructions to obtain an API key here:
    https://developers.google.com/maps/documentation/streetview/
    """
    if not fname:
        fname = "%s_%s_%s" % (year, panoid, str(heading))
    image_format = extension if extension != "jpg" else "jpeg"

    url = "https://maps.googleapis.com/maps/api/streetview"
    params: dict[str, str | int] = {
        # maximum permitted size for free calls
        "size": "%dx%d" % (width, height),
        "fov": fov,
        "pitch": pitch,
        "heading": heading,
        "pano": panoid,
        "key": key,
    }

    response = requests.get(url, params=params, stream=True)
    try:
        img = Image.open(BytesIO(response.content))
        filename = "%s/%s.%s" % (flat_dir, fname, extension)
        img.save(filename, image_format)
    except Exception:
        print("Image not found")
        filename = None
    del response

    return filename


def download_flats(
    panoid: str,
    flat_dir: str,
    key: str,
    width: int = 400,
    height: int = 300,
    fov: int = 120,
    pitch: int = 0,
    extension: str = "jpg",
    year: int = 2017,
) -> None:
    for heading in [0, 90, 180, 270]:
        api_download(
            panoid, heading, flat_dir, key, width, height, fov, pitch, extension, year
        )
